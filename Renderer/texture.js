import { zBuffer } from "../index.js";
import { brickTexture } from "../preload.js";

function swap(a, b) {
  return [b, a];
}

export function texturedTriangle(tri) {
  const scaleX = width / 2;
  const scaleY = height / 2;
  let y1 = Math.round(tri.vertices[0].y * scaleY);
  let y2 = Math.round(tri.vertices[1].y * scaleY);
  let y3 = Math.round(tri.vertices[2].y * scaleY);
  let x1 = Math.round(tri.vertices[0].x * scaleX);
  let x2 = Math.round(tri.vertices[1].x * scaleX);
  let x3 = Math.round(tri.vertices[2].x * scaleX);

  let u1 = tri.texture[0].u;
  let u2 = tri.texture[1].u;
  let u3 = tri.texture[2].u;
  let v1 = tri.texture[0].v;
  let v2 = tri.texture[1].v;
  let v3 = tri.texture[2].v;
  let w1 = tri.vertices[0].w;
  let w2 = tri.vertices[1].w;
  let w3 = tri.vertices[2].w;

  // y2 < y1
  if (y2 < y1) {
    // swap y1 and y2
    [y1, y2] = swap(y1, y2);
    // swap x1 and x2
    [x1, x2] = swap(x1, x2);

    // swap texture coordinates
    [u1, u2] = swap(u1, u2);
    [v1, v2] = swap(v1, v2);
    [w1, w2] = swap(w1, w2);
  }

  // y3 < y1
  if (y3 < y1) {
    // swap y1 and y3
    [y1, y3] = swap(y1, y3);
    // swap x1 and x3
    [x1, x3] = swap(x1, x3);

    // swap texture coordinates
    [u1, u3] = swap(u1, u3);
    [v1, v3] = swap(v1, v3);
    [w1, w3] = swap(w1, w3);
  }

  // y3 < y2
  if (y3 < y2) {
    // swap y2 and y3
    [y2, y3] = swap(y2, y3);
    // swap x2 and x3
    [x2, x3] = swap(x2, x3);

    // swap texture coordinates
    [u2, u3] = swap(u2, u3);
    [v2, v3] = swap(v2, v3);
    [w2, w3] = swap(w2, w3);
  }

  // copied from some thing cuz idk how to do textures
  // github repo: https://github.com/OneLoneCoder/Javidx9/tree/master/ConsoleGameEngine/BiggerProjects/Engine3D
  // f**king hell dumb ass shit

  let dy1 = y2 - y1; // y2 - y1
  let dx1 = x2 - x1; // x2 - x1
  let dv1 = v2 - v1; // v2 - v1
  let du1 = u2 - u1; // u2 - u1
  let dw1 = w2 - w1; // w2 - w1

  let dy2 = y3 - y1; // y3 - y1
  let dx2 = x3 - x1; // x3 - x1
  let dv2 = v3 - v1; // v3 - v1
  let du2 = u3 - u1; // u3 - u1
  let dw2 = w3 - w1; // w3 - w1

  let tex_u, tex_v, tex_w;

  // wtf is this
  let [
    dax_step,
    dbx_step,
    du1_step,
    dv1_step,
    du2_step,
    dv2_step,
    dw1_step,
    dw2_step,
  ] = new Array(8).fill(0);

  // ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€
  if (dy1) dax_step = dx1 / Math.abs(dy1);
  if (dy2) dbx_step = dx2 / Math.abs(dy2);

  if (dy1) du1_step = du1 / Math.abs(dy1);
  if (dy1) dv1_step = dv1 / Math.abs(dy1);
  if (dy1) dw1_step = dw1 / Math.abs(dy1);

  if (dy2) du2_step = du2 / Math.abs(dy2);
  if (dy2) dv2_step = dv2 / Math.abs(dy2);
  if (dy2) dw2_step = du2 / Math.abs(dy2);

  //   return;
  // OHHH MYY
  if (dy1) {
    for (let i = y1; i <= y2; i++) {
      let ax = x1 + (i - y1) * dax_step;
      let bx = x1 + (i - y1) * dbx_step;

      let tex_su = u1 + (i - y1) * du1_step;
      let tex_sv = v1 + (i - y1) * dv1_step;
      let tex_sw = w1 + (i - y1) * dw1_step;

      let tex_eu = u1 + (i - y1) * du2_step;
      let tex_ev = v1 + (i - y1) * dv2_step;
      let tex_ew = w1 + (i - y1) * dw2_step;

      if (ax > bx) {
        [ax, bx] = swap(ax, bx);
        [tex_su, tex_eu] = swap(tex_su, tex_eu);
        [tex_sv, tex_ev] = swap(tex_sv, tex_ev);
        [tex_sw, tex_ew] = swap(tex_sw, tex_ew);
      }

      tex_u = tex_su;
      tex_v = tex_sv;
      tex_w = tex_sw;

      let tstep = 1 / (bx - ax);
      let t = 0;

      for (let j = ax; j < bx; j++) {
        tex_u = (1 - t) * tex_su + t * tex_eu;
        tex_v = (1 - t) * tex_sv + t * tex_ev;
        tex_w = (1 - t) * tex_sw + t * tex_ew;
        if (tex_w > zBuffer[i * width + j]) {
          zBuffer[i * width + j] = tex_w;
          let color = brickTexture.getPixel(tex_u / tex_w, tex_v / tex_w);
          //   fill(color);
          //   rect(j, i, 1, 1);
        }

        t += tstep;
      }
    }
  }
  //   return;

  // thanks copilot for generating instead of me translating everything from C++ to p5js
  // lmao copilot just tried to generate 'i love you' to itself but no nononononono
  // ^ could be generated by copilot too woowowowoowoowowowowow

  dy1 = y3 - y2;
  dx1 = x3 - x2;
  du1 = u3 - u2;
  dv1 = v3 - v2;
  dw1 = w3 - w2;

  if (dy1) dax_step = dx1 / Math.abs(dy1);
  if (dy2) dbx_step = dx2 / Math.abs(dy2);

  du1_step = 0;
  dv1_step = 0;

  if (dy1) du1_step = du1 / Math.abs(dy1);
  if (dy1) dv1_step = dv1 / Math.abs(dy1);
  if (dy1) dw1_step = dw1 / Math.abs(dy1);

  if (dy1) {
    for (let i = y2; i <= y3; i++) {
      let ax = x2 + (i - y2) * dax_step;
      let bx = x1 + (i - y1) * dbx_step;

      let tex_su = u2 + (i - y2) * du1_step;
      let tex_sv = v2 + (i - y2) * dv1_step;
      let tex_sw = w2 + (i - y2) * dw1_step;

      let tex_eu = u1 + (i - y1) * du2_step;
      let tex_ev = v1 + (i - y1) * dv2_step;
      let tex_ew = w1 + (i - y1) * dw2_step;

      if (ax > bx) {
        [ax, bx] = swap(ax, bx);
        [tex_su, tex_eu] = swap(tex_su, tex_eu);
        [tex_sv, tex_ev] = swap(tex_sv, tex_ev);
        [tex_sw, tex_ew] = swap(tex_sw, tex_ew);
      }

      tex_u = tex_su;
      tex_v = tex_sv;
      tex_w = tex_sw;

      let tstep = 1 / (bx - ax);
      let t = 0;

      for (let j = ax; j < bx; j++) {
        tex_u = (1 - t) * tex_su + t * tex_eu;
        tex_v = (1 - t) * tex_sv + t * tex_ev;
        tex_w = (1 - t) * tex_sw + t * tex_ew;

        if (tex_w > zBuffer[i * width + j]) {
          zBuffer[i * width + j] = tex_w;
          let color = brickTexture.getPixel(tex_u / tex_w, tex_v / tex_w);
          //   fill(color);
          //   rect(j, i, 1, 1);
        }

        t += tstep;
      }
    }
  }
}
