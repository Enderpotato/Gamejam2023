import { zBuffer } from "../index.js";

function swap(a, b) {
  return [b, a];
}

export function texturedTriangle(tri) {
  /* 
      y1 == tri.vertices[0].y
      y2 == tri.vertices[1].y
      y3 == tri.vertices[2].y
      x1 == tri.vertices[0].x
      x2 == tri.vertices[1].x
      x3 == tri.vertices[2].x
      ... same for u, v, z
    */

  // y2 < y1
  if (tri.vertices[1].y < tri.vertices[0].y) {
    // swap y1 and y2
    [tri.vertices[0].y, tri.vertices[1].y] = swap(
      tri.vertices[0].y,
      tri.vertices[1].y
    );
    // swap x1 and x2
    [tri.vertices[0].x, tri.vertices[1].x] = swap(
      tri.vertices[0].x,
      tri.vertices[1].x
    );

    // swap texture coordinates
    [tri.texture[0], tri.texture[1]] = swap(tri.texture[0], tri.texture[1]);
  }

  // y3 < y1
  if (tri.vertices[2].y < tri.vertices[0].y) {
    // swap y1 and y3
    [tri.vertices[0].y, tri.vertices[2].y] = swap(
      tri.vertices[0].y,
      tri.vertices[2].y
    );
    // swap x1 and x3
    [tri.vertices[0].x, tri.vertices[2].x] = swap(
      tri.vertices[0].x,
      tri.vertices[2].x
    );

    // swap texture coordinates
    [tri.texture[0], tri.texture[2]] = swap(tri.texture[0], tri.texture[2]);
  }

  // y3 < y2
  if (tri.vertices[2].y < tri.vertices[1].y) {
    // swap y2 and y3
    [tri.vertices[1].y, tri.vertices[2].y] = swap(
      tri.vertices[1].y,
      tri.vertices[2].y
    );
    // swap x2 and x3
    [tri.vertices[1].x, tri.vertices[2].x] = swap(
      tri.vertices[1].x,
      tri.vertices[2].x
    );

    // swap texture coordinates
    [tri.texture[1], tri.texture[2]] = swap(tri.texture[1], tri.texture[2]);
  }

  // copied from some thing cuz idk how to do textures
  // github repo: https://github.com/OneLoneCoder/Javidx9/tree/master/ConsoleGameEngine/BiggerProjects/Engine3D
  // f**king hell dumb ass shit

  let dy1 = tri.vertices[1].y - tri.vertices[0].y; // y2 - y1
  let dx1 = tri.vertices[1].x - tri.vertices[0].x; // x2 - x1
  let dv1 = tri.texture[1].v - tri.texture[0].v; // v2 - v1
  let du1 = tri.texture[1].u - tri.texture[0].u; // u2 - u1
  let dw1 = tri.texture[1].w - tri.texture[0].w; // w2 - w1

  let dy2 = tri.vertices[2].y - tri.vertices[0].y; // y3 - y1
  let dx2 = tri.vertices[2].x - tri.vertices[0].x; // x3 - x1
  let dv2 = tri.texture[2].v - tri.texture[0].v; // v3 - v1
  let du2 = tri.texture[2].u - tri.texture[0].u; // u3 - u1
  let dw2 = tri.texture[2].w - tri.texture[0].w; // w3 - w1

  let tex_u, tex_v, tex_w;

  // wtf is this
  let [
    dax_step,
    dbx_step,
    du1_step,
    dv1_step,
    du2_step,
    dv2_step,
    dw1_step,
    dw2_step,
  ] = new Array(8).fill(0);

  // ðŸ’€ðŸ’€ðŸ’€ðŸ’€ðŸ’€
  if (dy1) dax_step = dx1 / Math.abs(dy1);
  if (dy2) dbx_step = dx2 / Math.abs(dy2);

  if (dy1) du1_step = du1 / Math.abs(dy1);
  if (dy1) dv1_step = dv1 / Math.abs(dy1);
  if (dy1) dw1_step = dw1 / Math.abs(dy1);

  if (dy2) du2_step = du2 / Math.abs(dy2);
  if (dy2) dv2_step = dv2 / Math.abs(dy2);
  if (dy2) dw2_step = du2 / Math.abs(dy2);

  // OHHH MYY
  if (dy1) {
    for (let i = y1; i <= y2; i++) {
      let ax = x1 + (i - y1) * dax_step;
      let bx = x1 + (i - y1) * dbx_step;

      let tex_su = u1 + (i - y1) * du1_step;
      let tex_sv = v1 + (i - y1) * dv1_step;
      let tex_sw = w1 + (i - y1) * dw1_step;

      let tex_eu = u1 + (i - y1) * du2_step;
      let tex_ev = v1 + (i - y1) * dv2_step;
      let tex_ew = w1 + (i - y1) * dw2_step;

      if (ax > bx) {
        [ax, bx] = swap(ax, bx);
        [tex_su, tex_eu] = swap(tex_su, tex_eu);
        [tex_sv, tex_ev] = swap(tex_sv, tex_ev);
        [tex_sw, tex_ew] = swap(tex_sw, tex_ew);
      }

      tex_u = tex_su;
      tex_v = tex_sv;
      tex_w = tex_sw;

      let tstep = 1 / (bx - ax);
      let t = 0;

      for (let j = ax; j < bx; j++) {
        tex_u = (1 - t) * tex_su + t * tex_eu;
        tex_v = (1 - t) * tex_sv + t * tex_ev;
        tex_w = (1 - t) * tex_sw + t * tex_ew;

        if (tex_w > zbuffer[i * width + j]) {
          zbuffer[i * width + j] = tex_w;
          let color = texture.sample(tex_u / tex_w, tex_v / tex_w);
          set(j, i, color);
        }

        t += tstep;
      }
    }
  }

  // thanks copilot for generating instead of me translating everything from C++ to p5js
  // lmao copilot just tried to generate 'i love you' to itself but no nononononono
  // ^ could be generated by copilot too woowowowoowoowowowowow

  dy1 = y3 - y2;
  dx1 = x3 - x2;
  du1 = u3 - u2;
  dv1 = v3 - v2;
  dw1 = w3 - w2;

  if (dy1) dax_step = dx1 / Math.abs(dy1);
  if (dy2) dbx_step = dx2 / Math.abs(dy2);

  du1_step = 0;
  dv1_step = 0;

  if (dy1) du1_step = du1 / Math.abs(dy1);
  if (dy1) dv1_step = dv1 / Math.abs(dy1);
  if (dy1) dw1_step = dw1 / Math.abs(dy1);

  if (dy1) {
    for (let i = y2; i <= y3; i++) {
      let ax = x2 + (i - y2) * dax_step;
      let bx = x1 + (i - y1) * dbx_step;

      let tex_su = u2 + (i - y2) * du1_step;
      let tex_sv = v2 + (i - y2) * dv1_step;
      let tex_sw = w2 + (i - y2) * dw1_step;

      let tex_eu = u1 + (i - y1) * du2_step;
      let tex_ev = v1 + (i - y1) * dv2_step;
      let tex_ew = w1 + (i - y1) * dw2_step;

      if (ax > bx) {
        [ax, bx] = swap(ax, bx);
        [tex_su, tex_eu] = swap(tex_su, tex_eu);
        [tex_sv, tex_ev] = swap(tex_sv, tex_ev);
        [tex_sw, tex_ew] = swap(tex_sw, tex_ew);
      }

      tex_u = tex_su;
      tex_v = tex_sv;
      tex_w = tex_sw;

      let tstep = 1 / (bx - ax);
      let t = 0;

      for (let j = ax; j < bx; j++) {
        tex_u = (1 - t) * tex_su + t * tex_eu;
        tex_v = (1 - t) * tex_sv + t * tex_ev;
        tex_w = (1 - t) * tex_sw + t * tex_ew;

        if (tex_w > zbuffer[i * width + j]) {
          zbuffer[i * width + j] = tex_w;
          let color = texture.sample(tex_u / tex_w, tex_v / tex_w);
          set(j, i, color);
        }

        t += tstep;
      }
    }
  }
}

function sampleFromTexture(texture, u, v) {
  let x = Math.floor(u * texture.width);
  let y = Math.floor(v * texture.height);
  return texture.get(x, y);
}
